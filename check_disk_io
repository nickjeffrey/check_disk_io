#!/usr/bin/perl -w

#
#  Nagios plugin for determining disk IO load.
#  Tested on Linux, FreeBSD, AIX, MacOS
#

# OUTSTANDING TASKS
# -----------------
#  1) test on FreeBSD, Solaris, HPUX
#  2) Add functionality to AIX section to detect vpath# disks (ie using IBM SDD multipath driver)
#  3) Add functionality to AIX section to detect vdiskpower# disks (ie using EMC PowerPath multipath driver)
#  4) Instead of alerting on the first busy disk, get a list of all the busy disks, and send them in a single alert.




# CHANGE LOG
# ----------
#   2010-08-18  njeffrey@anisoftgroup.com	Script created for AIX systems
#   2011-03-05  njeffrey@anisoftgroup.com	Add verbose variable for debugging
#   2011-03-05  njeffrey@anisoftgroup.com	Bug fix in reporting disk name 
#   2011-06-27  njeffrey@anisoftgroup.com	Add FreeBSD support
#   2011-06-27  njeffrey@anisoftgroup.com	Add Linux   support
#   2012-12-25  njeffrey@anisoftgroup.com       Add nagios perfdata to output
#   2017-02-02  njeffrey@anisoftgroup.com       Update Linux iostat command to take average of ten 1-second readings instead of a single reading
#   2017-02-02  njeffrey@anisoftgroup.com       Add support for Raspberry Pi computers using sdcard storage
#   2017-10-29  njeffrey@anisoftgroup.com	Add MacOS support




# NOTES
# -----
#  This script should return one (and only one) line of ouput.  Multiple
#  lines of output are silently ignored by nagios.
#
#  The line of output will become the body of the alert message sent by nagios
#
#
#
#  This script is executed remotely on a monitored system by the NRPE or check_by_ssh
#  methods available in nagios.  You will need to add a section similar to the following
#  to the services.cfg file on the nagios server.  Please note that this example assumes
#  you are using the check_by_ssh method for remotely executing nagios checks.  This assumes
#  that you already have ssh key pairs configured.
#      define service {
#              use                             generic-24x7-service
#              hostgroup_name                  all_aix,all_linux,all_freebsd,all_macos
#              service_description             Check disk IO
#              check_command                   check_by_ssh!/usr/local/nagios/libexec/check_disk_io
#              }


use diagnostics;                                #tell the perl interpreter to give us verbose messages while debugging
use strict;                                     #enforce good coding practices





# define variables
my $iostat              = "";                   			#location of iostat binary
my $uname               = "";                   			#location of uname binary
my $disk_name           = "";                   			#variable to hold name of disk (for multidisk systems)
my $iops                = "";                   			#variable to hold current iops on a disk
my %io;               							#hash to contain disk names and perf stats
my $MBps                = "";						#variable to hold MBps throughput of disk
my $ostype              = "";						#assorted UNIX flavors have their quirks.  Figure out what OS we are running on.
my $key                 = "";						#placeholder for looping through hash keys
my $percent_busy        = "";						#variable to hold %busy for those operating systems that report this value
my $disk_busy_threshold = 40;						#alert when disk busy % reaches this value
my $verbose             = "no";						#yes/no flag for verbose output for debugging
my ($freebsd_disk,@freebsd_disks);					#array to hold names of disks on FreeBSD
my ($macos_disk,@macos_disks);						#array to hold names of disks on MacOS
my $common_output_data  = "";						#holds the portion of output that is common across all output messages
my $perf_data           = "";						#holds nagios performance data
my ($OK,$WARN,$CRITICAL,$UNKNOWN,$CHECK_NAME);				#define variables

$CHECK_NAME= "disk io";							#define name of nagios check
#
# Nagios return codes
#
$OK=            0;                              			#this script returns a value to nagios for processing
$WARN=          1;                              			#this script returns a value to nagios for processing
$CRITICAL=      2;                              			#this script returns a value to nagios for processing
$UNKNOWN=       3;                              			#this script returns a value to nagios for processing






sub sanity_checks {
   print "running sanity_checks subroutine \n" if ($verbose eq "yes");
   #
   # confirm the iostat binary exists and is executable
   #
   $iostat = "/usr/bin/iostat";						#give a default location
   $iostat = "/usr/bin/iostat"  if ( -e "/usr/bin/iostat");		#location on AIX, Linux
   $iostat = "/usr/sbin/iostat" if ( -e "/usr/sbin/iostat");		#location on FreeBSD
   if ( ! -e $iostat ) {
      print "$CHECK_NAME CRITICAL - Cannot find $iostat binary. If you are using Linux, try yum install sysstat\n";
      exit( $CRITICAL );
   }
   if ( ! -x $iostat ) {
      print "$CHECK_NAME CRITICAL - $iostat binary is not executable by the current user.\n";
      exit( $CRITICAL );
   }
   #
   # confirm the uname binary exists and is executable
   #
   $uname = "/usr/bin/uname";						#give a default location
   $uname = "/usr/bin/uname"  if ( -e "/usr/bin/uname");		#location on AIX, FreeBSD
   $uname = "/bin/uname"      if ( -e "/bin/uname");			#location on Linux
   if ( ! -e $uname ) {
      print "$CHECK_NAME CRITICAL - Cannot find $uname binary \n";
      exit( $CRITICAL );
   }
   if ( ! -x $uname ) {
      print "$CHECK_NAME CRITICAL - $uname binary is not executable by the current user \n";
      exit( $CRITICAL );
   }		
}		 						#end of subroutine




sub run_iostat {
   print "running run_iostat subroutine \n" if ($verbose eq "yes");
   #
   # Figure out what operating system is running
   $ostype = "unknown";						#initialize variable 
   open(IN,"$uname|");      					#open filehandle using command output
   while (<IN>) {                                               #read a line from filehandle
      $ostype = "Linux"   if ( /Linux/)   ;
      $ostype = "FreeBSD" if ( /FreeBSD/) ;
      $ostype = "AIX"     if ( /AIX/)     ;
      $ostype = "SunOS"   if ( /SunOS/)   ;
      $ostype = "HP-UX"   if ( /HP-UX/)   ;
      $ostype = "MacOS"   if ( /Darwin/)  ;
   }								#end of while loop
   close IN;							#close filehandle
   print "   Detected operating system: $ostype \n" if ($verbose eq "yes");
   #
   #
   #
   if ( $ostype eq "SunOS" ) {
      print "$CHECK_NAME UNKNOWN - this check has not been tested against Solaris.  Please feel free to update this check and send patches to the author.\n";
      exit( $UNKNOWN );
   }								#end of if block
   #
   #
   #
   elsif ( $ostype eq "HP-UX" ) {
      print "$CHECK_NAME UNKNOWN - this check has not been tested against HP-UX.  Please feel free to update this check and send patches to the author.\n";
      exit( $UNKNOWN );
   }								#end of if block
   #
   #
   #
   elsif ( $ostype eq "FreeBSD" ) {
      #
      # This is the output of "iostat -t da " from a FreeBSD system
      #      
      #     tty             ad2             cpu
      # tin tout  KB/t tps  MB/s  us ni sy in id
      #   0   63 14.10  33  0.46   1  0  1  0 98
      #
      # The FreeBSD iostat command does not break out the disk stats one per line, which makes it hard to parse.
      # Let's do this in a few steps.  First, we will figure out the disks that exist, then get each of the iostat details separately.
      open(IN,"$iostat -d -t da | head -n 1 |");    		#figure out the names of the hard disks
      #
      # the above command gives us output similar to the following.  We want to capture the disk names ad1 and ad2
      #  iostat -d -t da
      #             ad1              ad2
      #  KB/t tps  MB/s   KB/t tps  MB/s
      # 14.10  33  0.46  12.60  26  2.81
      # 
      while (<IN>) {    					#read a line from filehandle
         @freebsd_disks = split(/ +/);				#the disk names are already in the $_ variable
         print "   Found the following disks: @freebsd_disks \n" if ($verbose eq "yes");
      }  							#end of while loop
      close IN;							#close filehandle
      #
      #
      foreach $freebsd_disk (@freebsd_disks) {
         next unless ( $freebsd_disk =~ /[a-z0-9]+/ );		#skip any invalid disk names
         print "   Running iostat -d $freebsd_disk \n" if ($verbose eq "yes");
         open(IN,"$iostat -d $freebsd_disk | tail -n 1 |");    				#open filehandle using command output
         while (<IN>) {    					#read a line from filehandle
            # Note that the following regex excludes disks containing numbers, as they are slices of a parent device, and therefore redundant.
            if ( /([0-9\.]+) +([0-9\.]+) +([0-9\.]+)/ ) {
               $disk_name    = $freebsd_disk;			#assign more mnemonic variable name
               $iops         = $2;				#FreeBSD refers to IOPS as tps (Transacions Per Second)
               $MBps         = $3;				#
               $percent_busy = "0";				#FreeBSD does not track disk % busy, so set it as zero.
               $io{$disk_name}{disk_name}=$disk_name;		#add value to hash
               $io{$disk_name}{iops}=$iops;			#add value to hash
               $io{$disk_name}{MBps}=$MBps;			#add value to hash
               $io{$disk_name}{MBps}= sprintf("%.2f",$io{$disk_name}{MBps}); #truncate to 2 decimal places
               $io{$disk_name}{percent_busy}=$percent_busy;	#add value to hash
               print "disk_name=$disk_name percent_busy=$percent_busy iops=$iops MBps=$MBps \n" if ($verbose eq "yes");
            }							#end of if block
         }							#end of while loop 
         close IN;						#close filehandle
      }								#end of foreach block
   }								#end of if block
   #
   #
   #
   elsif ( $ostype eq "MacOS" ) {
      #
      # This is the output of "iostat -d" from a MacOS system.
      #      
      #              disk0              disk1
      #    KB/t  tps  MB/s    KB/t  tps  MB/s
      #   32.73   37  1.19   57.24   91  9.43
      #
      # Column headers are: 
      #  KB/t    kilobytes per transfer
      #  tps     transactions per second
      #  MB/s    megabytes per second
      #
      # The MacOS iostat command does not break out the disk stats one per line, which makes it hard to parse.
      # Let's do this in a few steps.  First, we will figure out the disks that exist, then get each of the iostat details separately.
      open(IN,"$iostat -d | head -n 1 |");    		#figure out the names of the hard disks
      #
      # the above command gives us output similar to the following.  We want to capture the disk names disk0 and disk1
      #  iostat -d 
      #              disk0              disk1
      #    KB/t  tps  MB/s    KB/t  tps  MB/s
      #   32.73   37  1.19   57.24   91  9.43
      # 
      while (<IN>) {    					#read a line from filehandle
         @macos_disks = split(/ +/);				#the disk names are already in the $_ variable
         print "   Found the following disks: @macos_disks \n" if ($verbose eq "yes");
      }  							#end of while loop
      close IN;							#close filehandle
      #
      #
      foreach $macos_disk (@macos_disks) {
         next unless ( $macos_disk =~ /disk[0-9]+/ );		#skip any invalid disk names
         print "   Running iostat -d -c 10 -n 1 $macos_disk \n" if ($verbose eq "yes");
         open(IN,"$iostat -d -c 10 -n 1 $macos_disk |"); 	#open filehandle using command output
         while (<IN>) {    					#read a line from filehandle
            next if ( /disk[0-9]+/ );				#skip lines containing the disk name (disk0,disk1,disk2,etc)
            if ( /([0-9\.]+) +([0-9\.]+) +([0-9\.]+)/ ) {
               $disk_name    = $macos_disk;			#assign more mnemonic variable name
               $iops         = $2;				#MacOS refers to IOPS as tps (Transacions Per Second)
               $MBps         = $3;				#
               $percent_busy = "0";				#MacOS does not track disk % busy, so set it as zero.
               #
               # initialize hash elements if they do not already exist
               $io{$disk_name}{iops}=0           unless $io{$disk_name}{iops};
               $io{$disk_name}{MBps}=0           unless $io{$disk_name}{MBps};
               $io{$disk_name}{percent_busy}=0   unless $io{$disk_name}{percent_busy};
               #
               # Running total of IOPS and MB/second and percent busy
               $io{$disk_name}{disk_name}    = $disk_name;                                         #add value to hash
               $io{$disk_name}{iops}         = $io{$disk_name}{iops} + $iops;                      #running total of IOPS
               $io{$disk_name}{MBps}         = $io{$disk_name}{MBps} + $MBps;                      #running total of MBps
               $io{$disk_name}{percent_busy} = $io{$disk_name}{percent_busy} + $percent_busy;      #running total of percent busy time on disk
               print "   Running Total: disk_name=$disk_name iops=$iops MBps=$MBps \n" if ($verbose eq "yes");
            }							#end of if block
         }							#end of while loop 
         close IN;						#close filehandle
         #
         ## At this point, we have a running total of 10 iostat iterations.
         # Now calculate the average by dividing by 10
         foreach $key (sort keys %io) {                               #loop through for each disk
            $io{$key}{iops} =         $io{$key}{iops}         / 10;        #divide by 10 to get average
            $io{$key}{MBps} =         $io{$key}{MBps}         / 10;        #divide by 10 to get average
            $io{$key}{percent_busy} = $io{$key}{percent_busy} / 10;        #divide by 10 to get average
            #
            $io{$key}{iops}         = sprintf("%.0f",$io{$key}{iops});         #truncate to 0 decimal places
            $io{$key}{MBps}         = sprintf("%.0f",$io{$key}{MBps});         #truncate to 0 decimal places
            $io{$key}{percent_busy} = sprintf("%.0f",$io{$key}{percent_busy}); #truncate to 0 decimal places
            print "   Average: disk_name=$io{$key}{disk_name} iops=$io{$key}{iops} MBps=$io{$key}{MBps} \n" if ($verbose eq "yes");
         }                                                                 #end of foreach loop
      }								#end of foreach block
   }								#end of if block
   #
   #
   #
   elsif ( $ostype eq "Linux" ) {
      #
      # This is the output of "iostat -d -x -m" from a Linux system.  Note that the -x switch is only supported on 2.5+ kernels
      # Linux 2.6.18-164.15.1.el5 (rhel01.example.com)  10/18/2010
      #
      # Device:         rrqm/s   wrqm/s   r/s   w/s    rMB/s    wMB/s avgrq-sz avgqu-sz   await  svctm  %util
      # sda               0.04     7.04  0.07  3.44     0.00     0.04    24.40     0.02    5.33   0.39   0.14
      # sda1              0.00     0.00  0.00  0.00     0.00     0.00    17.46     0.00    3.21   2.70   0.00
      # sda2              0.03     7.04  0.07  3.44     0.00     0.04    24.40     0.02    5.33   0.39   0.14
      # dm-0              0.00     0.00  0.11 10.48     0.00     0.04     8.10     0.04    3.95   0.13   0.14
      # dm-1              0.00     0.00  0.00  0.00     0.00     0.00     8.00     0.00    4.20   0.30   0.00
      # mmcblk0           0.00     0.00  0.00  0.00     0.00     0.00     8.00     0.00    4.20   0.30   0.00   <--- this is an SD card on a Raspberry Pi
      #
      #
      # NOTES:  SCSI   disks use this naming format:  /dev/sda  /dev/sdb  /dev/sdc
      #         SATA   disks use this naming format:  /dev/sda  /dev/sdb  /dev/sdc
      #         IDE    disks use this naming format:  /dev/hda  /dev/hdb  /dev/hdc
      #         Floppy disks use this naming format:  /dev/fd0  /dev/fd1  /dev/fd2
      #         SCSI CDROMs  use this naming format:  /dev/scd0 /dev/scd1 /dev/scd2
      #         SATA CDROMs  use this naming format:  /dev/sr0  /dev/sr1  /dev/sr2
      #         Raspberry Pi SD card uses this format:    /dev/mmcblk0             <---- this is the only device name we use containing a number
      #
      # Get the average of ten iostat iterations, to avoid false alarms when the very first iteration is unusually high
      open(IN,"$iostat -d -x -m 1 10|");                        #open filehandle using command output
      while (<IN>) {                                            #read a line from filehandle
         # We only want to monitor entire disks, not slices or partitions
         next if ( /^sd[a-z]+[0-9]/ );				#skip SCSI / SATA disk partitions (sda0, sda1, sdb3, etc)
         next if ( /^hd[a-z]+[0-9]/ );				#skip IDE         disk partitions (hda0, hda1, hdb3, etc)
         next if ( /^dm\-[0-9]/ );				#skip Linux DM disk multipath devices (dm-0, dm-1, etc)
         next if ( /^sr[0-9]/ );				#skip CDROM  drives  (sr0, sr1, etc)
         next if ( /^scd[0-9]/ );				#skip CDROM  drives  (scd0, scd1, etc)
         next if ( /^fd[0-9]/ );				#skip floppy drives  (fd0, fd1, etc)
         if ( /([a-zA-Z0-9]+) +([0-9\.]+) +([0-9\.]+) +([0-9\.]+) +([0-9\.]+) +([0-9\.]+) +([0-9\.]+) +([0-9\.]+) +([0-9\.]+) +([0-9\.]+) +([0-9\.]+) +([0-9\.]+)/ ) {
            $disk_name    = $1;                                 #assign more mnemonic variable name
            $iops         = $4 + $5;                            #add reads/sec and writes/sec to get total iops
            $MBps         = $6 + $7;                            #add rMB/s and wMB/s to get total MB/s
            $percent_busy = $12;                                #add rMB/s and wMB/s to get total MB/s
            #
            # initialize hash elements if they do not already exist
            $io{$disk_name}{iops}=0         unless $io{$disk_name}{iops};
            $io{$disk_name}{MBps}=0         unless $io{$disk_name}{MBps};
            $io{$disk_name}{percent_busy}=0 unless $io{$disk_name}{percent_busy};
            #
            # Running total of IOPS and MB/second and percent busy
            $io{$disk_name}{disk_name}    = $disk_name;                                         #add value to hash
            $io{$disk_name}{iops}         = $io{$disk_name}{iops} + $iops;                      #running total of IOPS
            $io{$disk_name}{MBps}         = $io{$disk_name}{MBps} + $MBps;                      #running total of MBps
            $io{$disk_name}{percent_busy} = $io{$disk_name}{percent_busy} + $percent_busy;      #running total of % busy
            print "   Running Total: disk_name=$disk_name percent_busy=$percent_busy iops=$iops MBps=$MBps \n" if ($verbose eq "yes");
         }                                                      #end of if block
      }                                                         #end of while loop
      close IN;                                                 #close filehandle
      #
      ## At this point, we have a running total of 10 iostat iterations.
      # Now calculate the average by dividing by 10
      foreach $key (sort keys %io) {                               	#loop through for each disk
         $io{$key}{iops} =         $io{$key}{iops}         / 10;        #divide by 10 to get average
         $io{$key}{MBps} =         $io{$key}{MBps}         / 10;        #divide by 10 to get average
         $io{$key}{percent_busy} = $io{$key}{percent_busy} / 10;        #divide by 10 to get average
         #
         $io{$key}{iops}         = sprintf("%.0f",$io{$key}{iops});         #truncate to 0 decimal places
         $io{$key}{MBps}         = sprintf("%.0f",$io{$key}{MBps});         #truncate to 0 decimal places
         $io{$key}{percent_busy} = sprintf("%.0f",$io{$key}{percent_busy}); #truncate to 0 decimal places
         print "   Average: disk_name=$io{$key}{disk_name} percent_busy=$io{$key}{percent_busy} iops=$io{$key}{iops} MBps=$io{$key}{MBps} \n" if ($verbose eq "yes");
      }                                                                 #end of foreach loop
   }								#end of if block
   #
   #
   #
   elsif ( $ostype eq "AIX" ) {
      #
      # This is the output from an AIX 6.x system:
      #
      # System configuration: lcpu=8 drives=15 paths=30 vdisks=2
      #
      # Disks:        % tm_act     Kbps      tps    Kb_read   Kb_wrtn
      # hdisk3           0.1       6.8       0.1   77126083   1404652
      # hdisk5           0.1       6.7       0.1   76307191    882732
      # hdisk2           2.9     315.0      12.0   3520527919  127619485
      # hdisk0           0.8      56.6       4.4   480889742  174546576
      #
      open(IN,"$iostat -d|");                                   #open filehandle using command output
      while (<IN>) {                                            #read a line from filehandle
         next if ( /System configuration/ );                    #skip header row
         next if ( /^Disks:/ );                                 #skip header row
         # Note that this regex looks for "hdisk", so SDD (which uses vpath#) and PowerPath (which uses vdiskpower#) are not supported by this check.
         if ( /(hdisk[0-9]+) +([0-9\.]+) +([0-9\.]+) +([0-9\.]+) +([0-9]+) +([0-9\.]+)/ ) {
            $disk_name    = $1;                                 #assign more mnemonic variable name
            $percent_busy = $2;                                 #assign more mnemonic variable name
            $iops         = $4;                                 #assign more mnemonic variable name
            $MBps         = $3;                                 #assign more mnemonic variable name
            $MBps         = $MBps / 1024;                       #divide by 1024 to convert Kbps to Mbps
            $MBps         = $MBps / 8;                          #divide by 8 to convert Mbps to MBps
            $io{$disk_name}{disk_name}=$disk_name;              #add value to hash
            $io{$disk_name}{iops}=$iops;                        #add value to hash
            $io{$disk_name}{MBps}=$MBps;                        #add value to hash
            $io{$disk_name}{MBps}= sprintf("%.2f",$io{$disk_name}{MBps}); #truncate to 2 decimal places
            $io{$disk_name}{percent_busy}=$percent_busy;        #add value to hash
            print "disk_name=$disk_name percent_busy=$percent_busy iops=$iops MBps=$MBps \n" if ($verbose eq "yes");
         }                                                      #end of if block
         if ( /Disk history since boot not available/ ) { 
            print "$CHECK_NAME UNKNOWN - disk accounting is not turned on for this system, so disk stats cannot be determined.  Please enable disk accounting with the following command: chdev -l sys0 -a \"iostat=true\" \n";
            exit( $UNKNOWN );
         }							#end of if block
      }                                                         #end of while loop
      close IN;                                                 #close filehandle
   }                                                            #end of if block
   #
   #
   #
   else {
      # send an "unknown" alert because we could not determine the operating system
      print "$CHECK_NAME UNKNOWN - could not determine operating system from uname output.  Please feel free to update this check and send patches to the author.\n";
      exit( $UNKNOWN );
   }								#end of if block
} 								#end of subroutine





sub print_output {
   print "running print_output subroutine \n" if ($verbose eq "yes");
   #
   #
   #
   #
   # The nagios performance data will be the same for all the outputs, so just put it in a variable that can be use by all the output options
   # The format is:  label=value[UOM];[warn];[crit];[min];[max]
   # On the "label=value" section is required.  The warn|crit|min|max entries are optional.
   # You can have multiple items of perf data, just separate each section with a space
   # UOM is Units Of Measurement.    Can be s=seconds B=bytes MB=megabytes %=percent c=counter
   foreach $key (sort keys %io) {       			#loop through for each disk
      next unless $key;                          		#skip any blank lines
      next if  ( $io{$key}{percent_busy} eq "unknown" );	#skip for operating systems that do not track this value
      $perf_data = "$perf_data $io{$key}{disk_name}_iops=$io{$key}{iops};;;; $io{$key}{disk_name}_MBps=$io{$key}{MBps};;;; $io{$key}{disk_name}_busy=$io{$key}{percent_busy}%;${disk_busy_threshold};;; ";
   }							#end of foreach block
   #
   #
   #
   # Much of the text of the output will be the same.  Put the common stuff in a variable so we can simplify the outputs
   foreach $key (sort keys %io) {       			#loop through for each disk
      next unless $key;                          		#skip any blank lines
      next if  ( $io{$key}{percent_busy} eq "unknown" );	#skip for operating systems that do not track this value
      $common_output_data = "$common_output_data $io{$key}{disk_name}_iops=$io{$key}{iops} $io{$key}{disk_name}_MBps=$io{$key}{MBps} $io{$key}{disk_name}_busy=$io{$key}{percent_busy}%";
   }							#end of foreach block
   #
   #
   # See how busy each of the disks are.
   # Note that this will alert on the first disk that breaches the threshold, and will not
   # report on additional disks that may also be too busy.
   #
   foreach $key (sort keys %io) {       			#loop through for each disk
      next unless $key;                          		#skip any blank lines
      next if  ( $io{$key}{percent_busy} eq "unknown" );	#skip for operating systems that do not track this value
      print "   disk=$io{$key}{disk_name} percent_busy=$io{$key}{percent_busy} \n" if ($verbose eq "yes");
      if ( $io{$key}{percent_busy} >= $disk_busy_threshold ) {
         print "$CHECK_NAME WARN - disk $io{$key}{disk_name} is $io{$key}{percent_busy} \% busy.  This is indicative of a very busy disk.  Disk performance may be a bottleneck.  $common_output_data | $perf_data \n";
         exit( $WARN );
      }								#end of if block
   }								#end of foreach loop
   #
   # We should only get here if there were no problems detected
   #
   print "$CHECK_NAME OK - $common_output_data | $perf_data  \n";			
   exit( $OK );
}                                                       #end of subroutine








# --------------- main body of program ------------------------------------
sanity_checks;
run_iostat;
print_output;



